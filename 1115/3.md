Yes, you can totally do a “9-camera control room” for the agent. Think of it as an **Agent Wall**: up to 9 parallel browser sessions, each showing live-ish screenshots plus what that sub-agent is doing.

Here’s a concrete plan that fits the architecture we already sketched.

---

## 1. Concept: “Agent Wall” for Browsing

When `ResearchCompanyWorkflow` hits `browse_and_extract_pages`, instead of everything happening invisibly, we:

* Spin up multiple Browser Use sessions **in parallel**, one per URL.
* After each navigation / major step, we:

  * Take a screenshot.
  * Save metadata (`url`, `page_type`, “current action”).
  * Store this as the current state of a **window slot** (0–8).
* Your UI polls the backend for “windows for run X” and renders a **3×3 CSS grid** of screenshots + overlays.

Even with ~2–3s polling, it looks very much like a live control room.

---

## 2. Data Model for Visual Windows

Add a small model representing the **current visual state** of each sub-agent:

```python
from pydantic import BaseModel, HttpUrl
from typing import Optional, Literal
from datetime import datetime

class AgentWindowState(BaseModel):
    slot: int                     # 0–8
    url: HttpUrl
    page_type: str                # "homepage", "pricing", "docs", "linkedin", "blog"
    status: Literal["starting", "loading", "reading", "extracting", "done", "error"]
    last_action: str              # e.g. "Scrolling to pricing section"
    screenshot_url: Optional[str] # /static/runs/{run_id}/slot_{slot}.png
    usefulness_score: Optional[float]
    updated_at: datetime
```

We’ll store **a list of 0–9 `AgentWindowState`** per run (workflow_id).

---

## 3. Where This Hooks Into the Workflow

In `ResearchCompanyWorkflow` we already have:

```python
page_extractions = await workflow.execute_activity(
    browse_and_extract_pages,
    company,
    policy,
    linkup_results,
    schedule_to_close_timeout=timedelta(minutes=5),
)
```

Inside the **activity** `browse_and_extract_pages` we’ll:

1. Determine which URLs to visit.
2. Assign each URL a `slot` (0–8). If >9 URLs, we can:

   * Either cap at 9 (simplest).
   * Or reuse slots once a URL is “done” (slightly fancier).
3. For each URL, run an async task:

   * Update its window state as it goes.
   * Take screenshots and save them to `/static/runs/{run_id}/slot_{slot}.png`.

---

## 4. Backend State Store for Window States

We need a place the **worker** can write to and the **app** can read from.

### Minimal hackathon approach (no extra infra)

* Use the filesystem + a simple JSON file per run:

  * `/data/runs/{run_id}/windows.json`
  * Screenshot PNGs: `/data/runs/{run_id}/slot_{slot}.png`
* Mount `/data` as a shared volume between `app` and `worker` containers in `docker-compose`.

**docker-compose snippet:**

```yaml
services:
  app:
    ...
    volumes:
      - ./data:/data

  worker:
    ...
    volumes:
      - ./data:/data
```

So both processes see the same files.

### Writing state from the activity

Every time a screenshot or status changes:

```python
import json, os
from datetime import datetime

RUN_DATA_DIR = "/data/runs"

def update_agent_window_state(run_id: str, window_state: AgentWindowState):
    run_dir = os.path.join(RUN_DATA_DIR, run_id)
    os.makedirs(run_dir, exist_ok=True)

    windows_json_path = os.path.join(run_dir, "windows.json")

    # Load existing
    windows = []
    if os.path.exists(windows_json_path):
        with open(windows_json_path, "r") as f:
            windows = [AgentWindowState(**w) for w in json.load(f)]

    # Replace or append this slot
    filtered = [w for w in windows if w.slot != window_state.slot]
    filtered.append(window_state)
    # Sort by slot for consistency
    filtered.sort(key=lambda w: w.slot)

    with open(windows_json_path, "w") as f:
        json.dump([w.dict() for w in filtered], f, default=str)
```

We can attach the **run_id** to the activity input (e.g. pass `workflow_id` from Temporal when starting the workflow; the worker can get it via `activity.info().workflow_id` too).

---

## 5. Taking Screenshots in `browse_and_extract_pages`

Inside `browse_and_extract_pages` (pseudo-code):

```python
from browser_use import Agent, Browser
from datetime import datetime

async def browse_and_extract_pages(company, policy, linkup_results, run_id: str):
    urls = pick_urls_to_visit(linkup_results, policy)[:9]  # cap at 9
    browser = await Browser.create()

    async def process_url(slot, url):
        agent = Agent(browser=browser)
        # 1) starting
        update_agent_window_state(
            run_id,
            AgentWindowState(
                slot=slot,
                url=url,
                page_type=infer_page_type(url),
                status="starting",
                last_action="Launching browser session",
                screenshot_url=None,
                usefulness_score=None,
                updated_at=datetime.utcnow(),
            ),
        )

        # 2) navigate and screenshot
        page = await browser.new_page()
        await page.goto(str(url), wait_until="networkidle")
        screenshot_path = f"/data/runs/{run_id}/slot_{slot}.png"
        await page.screenshot(path=screenshot_path, full_page=True)

        update_agent_window_state(
            run_id,
            AgentWindowState(
                slot=slot,
                url=url,
                page_type=infer_page_type(url),
                status="loading",
                last_action="Loaded page, starting extraction",
                screenshot_url=f"/static/runs/{run_id}/slot_{slot}.png",
                usefulness_score=None,
                updated_at=datetime.utcnow(),
            ),
        )

        # 3) run the Browser Use agent with a focused extraction task...
        # ... compute usefulness_score
        usefulness_score = ...

        update_agent_window_state(
            run_id,
            AgentWindowState(
                slot=slot,
                url=url,
                page_type=infer_page_type(url),
                status="done",
                last_action="Extraction completed",
                screenshot_url=f"/static/runs/{run_id}/slot_{slot}.png",
                usefulness_score=usefulness_score,
                updated_at=datetime.utcnow(),
            ),
        )

        # return PageExtraction(...)
        return PageExtraction(...)

    tasks = [
        process_url(slot, url)
        for slot, url in enumerate(urls)
    ]
    extractions = await asyncio.gather(*tasks)

    await browser.close()
    return extractions
```

Key points:

* Each URL/slot calls `update_agent_window_state` at least 3–4 times:

  * starting → loading → extracting → done
* Every screenshot overwrites the PNG for that slot, so the front-end always shows the latest state.

---

## 6. API Endpoint for the Agent Wall

Add a read-only endpoint that returns current window states for a given run / workflow.

```python
from fastapi import APIRouter, HTTPException
import os, json

router = APIRouter()

@router.get("/api/run/{run_id}/windows", response_model=list[AgentWindowState])
def get_run_windows(run_id: str):
    path = f"/data/runs/{run_id}/windows.json"
    if not os.path.exists(path):
        # no updates yet; just return empty list
        return []

    with open(path, "r") as f:
        data = json.load(f)
    return [AgentWindowState(**w) for w in data]
```

Mount `/static` to serve screenshots:

```python
from fastapi.staticfiles import StaticFiles

app.mount(
    "/static",
    StaticFiles(directory="/data"),
    name="static",
)
```

Now `/static/runs/{run_id}/slot_0.png` works in the browser.

---

## 7. UI: 3×3 Agent Wall

On your **Run Agent** page, below the form, add a big “Agent Wall” section.

### Layout (Tailwind-ish):

```html
<section class="mt-8">
  <div class="flex items-center justify-between mb-2">
    <h2 class="text-lg font-semibold text-slate-100">Agent Wall</h2>
    <span class="text-xs text-slate-400">Live view of up to 9 browsing agents</span>
  </div>

  <div id="agent-wall"
       class="grid grid-cols-3 gap-3 h-[420px]">
    <!-- 9 slots, filled with live state -->
  </div>
</section>
```

Each **slot** card:

```html
<div class="relative bg-slate-900/60 rounded-xl overflow-hidden border border-slate-700/60">
  <img src="{{ screenshot_url }}"
       class="w-full h-full object-cover opacity-80"
       alt="Agent view">

  <!-- Gradient overlay for text readability -->
  <div class="absolute inset-0 bg-gradient-to-t from-black/70 via-black/20 to-transparent"></div>

  <!-- Top left: domain + page type -->
  <div class="absolute top-2 left-2 px-2 py-1 rounded-full bg-black/60 text-xs text-slate-100 flex items-center gap-1">
    <span class="font-semibold truncate max-w-[100px]">{{ domain }}</span>
    <span class="text-slate-400">• {{ page_type }}</span>
  </div>

  <!-- Bottom left: status + last action -->
  <div class="absolute bottom-2 left-2 right-2 text-xs text-slate-100">
    <div class="flex items-center justify-between mb-1">
      <span class="inline-flex items-center gap-1">
        <span class="w-2 h-2 rounded-full
          {% if status == 'done' %} bg-emerald-400
          {% elif status == 'error' %} bg-rose-400
          {% else %} bg-amber-300 animate-pulse{% endif %}">
        </span>
        <span class="uppercase tracking-wide text-[0.6rem] text-slate-300">
          {{ status | upper }}
        </span>
      </span>
      {% if usefulness_score is not none %}
        <span class="text-[0.6rem] text-slate-300">
          Usefulness: {{ (usefulness_score * 100) | round(0) }}%
        </span>
      {% endif %}
    </div>
    <p class="text-[0.65rem] text-slate-200 line-clamp-2">
      {{ last_action }}
    </p>
  </div>
</div>
```

If a slot is **empty** (no data yet), show a placeholder with an icon and “Waiting for assignment”.

### Polling for updates

Use simple JS (or HTMX) to poll `/api/run/{run_id}/windows` every 2 seconds while the run is active:

```html
<script>
  let currentRunId = null;
  let pollInterval = null;

  function startAgentWallPolling(runId) {
    currentRunId = runId;
    if (pollInterval) clearInterval(pollInterval);

    async function poll() {
      try {
        const res = await fetch(`/api/run/${currentRunId}/windows`);
        const windows = await res.json();
        renderAgentWall(windows);
      } catch (e) {
        console.error('Error polling agent wall', e);
      }
    }

    poll();
    pollInterval = setInterval(poll, 2000);
  }

  function renderAgentWall(windows) {
    const wall = document.getElementById('agent-wall');
    // Initialize 9 empty slots
    const slots = Array.from({ length: 9 }, (_, i) => ({
      slot: i,
      status: 'idle',
      last_action: 'Waiting for task...',
      screenshot_url: '/static/placeholder.png',
      url: '',
      page_type: '',
      usefulness_score: null,
    }));

    for (const w of windows) {
      slots[w.slot] = w;
    }

    wall.innerHTML = slots.map(slotToHtml).join('');
  }

  function slotToHtml(w) {
    // build HTML string using template literals (similar to snippet above)
  }
</script>
```

When you **kick off the workflow** (on “Run Research Agent” button):

* Backend returns `{ workflow_id: "..." }` (use that as `run_id`).
* Immediately call `startAgentWallPolling(workflow_id)`.

Result: as soon as `browse_and_extract_pages` starts updating JSON + screenshots, the wall starts animating.

---

## 8. Docker: make screenshots reachable

We already mounted `./data:/data` in both `app` and `worker` containers.

Add a `placeholder.png` into `./data/static/placeholder.png` or just `./data/placeholder.png` and point your UI to that when there’s no screenshot yet.

FastAPI static mount (again):

```python
from fastapi.staticfiles import StaticFiles
app.mount("/static", StaticFiles(directory="/data"), name="static")
```

So:

* actual screenshots: `/data/runs/{run_id}/slot_{slot}.png`
* browser URL: `/static/runs/{run_id}/slot_{slot}.png`

---

## 9. How to Show This to Judges

In your 3-minute demo, you now have an extra “wow” moment:

1. Start a run.
2. Immediately scroll to the **Agent Wall**:

   * The 9 slots appear.
   * Within a second or two, they light up with screenshots of the homepage, pricing, docs, etc.
   * Status dots pulse as agents move from starting → loading → extracting → done.
3. Then you flip down to the brief/outreach tabs to show the distilled output.

You can literally say:

> “On the left, you see our Temporal workflows orchestrating 9 browser agents via Browser Use.
> On the right, the Agent Wall shows exactly what each sub-agent is doing in real time, making the autonomy and self-evolution tangible.”

---

If you’d like, I can next:

* Draft the actual FastAPI route + minimal HTML/JS for the Agent Wall section (ready to paste), or
* Sketch the `browse_and_extract_pages` activity with real Playwright screenshot calls in more detail.
