Nice, let’s wrap this into something demo-ready and pretty. I’ll give you:

1. **UI/UX design** (screens, layout, flows, styling)
2. **How it talks to Temporal** (API + polling)
3. **Container plan** (single Dockerfile + docker-compose with Temporal server + app + worker)

I’ll keep it hackathon-practical.

---

## 1. Overall UX: What the judges will see

### Pages / sections

You only really need **one web app** with three main views:

1. **Run Agent (Home)**

   * Input form for company
   * Live run status
   * Result snapshot (brief, outreach message, visual, metrics)

2. **History**

   * Table of past runs with key metrics
   * Click to open any snapshot

3. **Policy Evolution**

   * Timeline / list of policy versions
   * Quick diff of key parameters
   * “Current policy” card

You can make this a single-page app with tabs.

### Visual style

* **Layout:** Centered, max-width `1200px`, large top hero.
* **Palette:**

  * Background: `#050816` (dark navy) or `#030712`
  * Primary accent: teal (`#14b8a6`)
  * Secondary accent: purple/indigo (`#6366f1`)
  * Text: light gray (`#e5e7eb`)
* **Typography:**

  * Heading: Inter / Sora, bold, tracking-tight.
  * Body: Inter/Roboto.
* **Components:**

  * Glassmorphism cards: slightly transparent and blurred backgrounds.
  * Pills/chips for statuses and policy versions.
  * Sponsor badges row (“Linkup”, “LiquidMetal/SmartBuckets”, “Freepik”, “Anthropic”).

You can get away with Tailwind + a tiny bit of custom CSS.

---

## 2. Home / “Run Agent” Screen

### Layout

**Top section (hero):**

* Left:

  * Title: **“Self-Evolving Account Researcher”**
  * Subtitle: *“Temporal-orchestrated browser agent that keeps your account research and outreach up-to-date and self-improving.”*
  * Small row of sponsor tool chips:

    * `Linkup` • `LiquidMetal SmartBuckets` • `Freepik` • `Anthropic` • `Browser Use` • `Temporal`

* Right:

  * Metric mini-cards:

    * “Avg Page Usefulness (last 10 runs)”
    * “Policy Version”
    * “Runs Completed”

**Middle section: two columns**

* **Left card – “Run Agent” form**

  * Inputs:

    * `Company Name` (required)
    * `Website Domain` (optional)
    * `Persona` (dropdown: “SDR”, “AE”, “Partnerships”, “Custom”)
    * `Notes` (optional text area to give extra context)
  * Buttons:

    * Primary: **Run Research Agent**
    * Secondary: **Run Quick Demo** (pre-fills with a known company to avoid network issues)
  * Status area:

    * Status pill: `Idle` / `Running` / `Completed` / `Error`
    * Progress steps with check icons:

      1. “Linkup search”
      2. “Browsing and extraction”
      3. “Summarizing with Claude”
      4. “Generating visual”
      5. “Saving to SmartBuckets”

* **Right card – “Latest Snapshot”**

  * If no run yet: simple placeholder text “Run the agent to see a snapshot here.”
  * When run is complete:

    * Company name + domain
    * Policy version chip: `Policy v2`
    * Time: “Completed 2 minutes ago”
    * Key metrics:

      * Pages visited
      * Avg usefulness score (progress bar)
      * # Linkup results
    * Buttons:

      * “Expand Details”
      * “View Policy Evolution”

**Bottom section – Detailed Result Tabs (appear after run)**

Tabs:

1. **Brief**

   * Render `brief_md` markdown as nice formatted text.
   * Use headings:

     * “Who They Are”
     * “What They Sell”
     * “Ideal Customer Profile”
     * “Key Signals”
     * “Risks / Questions”

2. **Outreach**

   * Show `outreach_message` in a code/monospace block with:

     * “Copy to Clipboard” button
     * Optional toggle: “LinkedIn / WhatsApp”

3. **Evidence**

   * Table of extracted pages:

     * Columns: `Page`, `Type`, `Usefulness`, `Key Points`, `Open`
     * Each row includes:

       * `url` short label (“/pricing”, “/about”)
       * `usefulness_score` as a small bar
       * Bullet list of 2–3 signals
       * “Open source page” link (opens in new tab)

4. **Visual Snapshot**

   * Show `freepik_asset_url` as background image.
   * Overlay (position: bottom-left):

     * Company name
     * 3 bullet points from signals
     * A one-liner “Suggested opener: ...”

---

## 3. History Screen

Accessible via a top nav tab: **“History”**.

### Layout

* Filter row:

  * Search field (company name)
  * Dropdown: `Policy Version (All / v1 / v2 / v3)`
* Table:

Columns:

* Company
* Run Time
* Policy Version
* Avg Usefulness (small bar)
* Pages Visited
* Tools Used (icons)
* Action: `View`

Each row click opens a **drawer** or full-screen page that shows the same snapshot layout as the home “Detailed Result” area.

Optional extras if you have time:

* Small chart at top: line graph of avg usefulness over time grouped by policy version.
* Policy version legend: colored dots for `v1`, `v2`, `v3`.

---

## 4. Policy Evolution Screen

Goal: make the “self-evolving” part visually obvious in 30 seconds.

### Layout

**Top – Current policy card**

* Title: “Current Browsing Policy: v2”
* Body:

  * `linkup_query_template` (code block)
  * `allowed_domains`
  * `preferred_paths`
  * `max_pages_per_domain`
* Small badge: “Last updated: 2025-11-15 by Self-Learning Workflow”

**Middle – Version timeline**

Horizontal or vertical timeline:

* v1 → v2 → v3
* Each node:

  * Version label
  * Date
  * Metric summary:

    * “Avg usefulness: 0.42”
    * “% pages that were pricing/about: 25%”
  * Button “View diff vs previous”

**Bottom – Diff view (selected version)**

If you click v2:

* Two-column layout:

Left: `v1` (old policy)
Right: `v2` (new policy)

Highlight changes:

* `preferred_paths`: `["/careers"]` removed, `["/pricing", "/solutions"]` added
* `linkup_query_template`: string diff with changed terms highlighted.
* `min_usefulness_threshold`: 0.4 → 0.6

Also show a mini comment from Claude:

> “I removed careers pages from the crawler preference because they contributed low usefulness scores and increased the page count without adding ICP or pricing info.”

You can store this “rationale” inside the policy JSON as `change_log`.

---

## 5. How the UI talks to Temporal

Assume **FastAPI backend** exposing REST endpoints, and UI is a frontend (could be Jinja templates, or a React SPA) calling these endpoints.

### API endpoints

1. `POST /api/run_research`

   * Body: `CompanyInput` JSON.
   * Behavior:

     * Calls Temporal client `start_workflow()` with `ResearchCompanyWorkflow`.
     * Returns `{ "workflow_id": "...", "run_id": "..." }`.

2. `GET /api/run_status?workflow_id=...`

   * Returns:

     * `status: "RUNNING" | "COMPLETED" | "FAILED"`
     * If completed: `snapshot_id`.
     * If failed: `error_message`.

3. `GET /api/snapshot/{snapshot_id}`

   * Returns a `CompanySnapshot` JSON.

4. `GET /api/history?limit=20` – returns list of lightweight snapshot summaries.

5. `GET /api/policy` – returns current `BrowsingPolicy`.

6. `GET /api/policy/versions` – returns all policy versions.

### Frontend behavior

* On “Run Research Agent” click:

  1. `POST /api/run_research` → get `workflow_id`.
  2. Start polling `GET /api/run_status` every 2 seconds until status is `COMPLETED` or `FAILED`.
  3. When completed:

     * Use `snapshot_id` to fetch `/api/snapshot/{snapshot_id}`.
     * Render details into the bottom result tabs and the “Latest Snapshot” card.

* “History” & “Policy Evolution” pages just call the corresponding APIs.

---

## 6. Tech stack for a “nice but fast” UI

For hackathon speed:

* **Backend:** FastAPI
* **Templates:** Jinja2
* **Styling:** Tailwind via CDN (no build step)
* **JS:** Vanilla + HTMX or a bit of Alpine.js for interactivity

If you want full React/Next.js, totally fine, but you then separate backend from frontend.

Minimal FastAPI structure:

```text
app/
  main.py              # FastAPI app + HTML routes
  api.py               # REST endpoints
  templates/
    base.html
    index.html         # Home + run view
    history.html
    policy.html
  static/
    css/custom.css
  temporal_client.py   # helper to talk to Temporal
  models.py
  ...
```

`index.html` uses Tailwind classes for layout and pulls in HTMX to:

* Submit the form via `hx-post="/api/run_research"`.
* Poll `hx-get="/api/run_status"` and swap status div.
* Load snapshot HTML partial once completed.

This gives you a surprisingly nice UI with very little JS.

---

## 7. Docker & Local Run Plan

You want:

* Temporal server
* Your FastAPI app (API + UI)
* Your Temporal worker(s)
* All running locally via Docker.

### 7.1 Single Dockerfile for the app + worker

**`Dockerfile`** (one image used by both `app` and `worker` services):

```dockerfile
FROM python:3.11-slim

# System deps
RUN apt-get update && apt-get install -y build-essential curl && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Install Python deps
COPY pyproject.toml poetry.lock* requirements.txt* ./
# choose poetry or pip; here assume requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Copy source
COPY app ./app

# Default envs (override in docker-compose)
ENV PYTHONUNBUFFERED=1 \
    TEMPORAL_HOST=temporal:7233

# Expose app port
EXPOSE 8000

# We'll override CMD in docker-compose:
# - one container runs the API
# - another runs the Temporal worker
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 7.2 docker-compose with Temporal + app + worker

**`docker-compose.yml`**:

```yaml
version: "3.8"

services:
  temporal:
    image: temporalio/auto-setup:latest
    container_name: temporal
    environment:
      - DB=sqlite
    ports:
      - "7233:7233"   # Temporal gRPC
      - "8233:8233"   # Temporal Web UI
    healthcheck:
      test: ["CMD", "tctl", "--address", "temporal:7233", "cluster", "health"]
      interval: 10s
      timeout: 5s
      retries: 5

  app:
    build: .
    container_name: app
    depends_on:
      temporal:
        condition: service_healthy
    environment:
      - TEMPORAL_HOST=temporal:7233
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - LINKUP_API_KEY=${LINKUP_API_KEY}
      - SMARTBUCKET_API_KEY=${SMARTBUCKET_API_KEY}
      - FREEPIK_API_KEY=${FREEPIK_API_KEY}
    ports:
      - "8000:8000"
    command: >
      uvicorn app.main:app
      --host 0.0.0.0
      --port 8000

  worker:
    build: .
    container_name: worker
    depends_on:
      temporal:
        condition: service_healthy
    environment:
      - TEMPORAL_HOST=temporal:7233
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - LINKUP_API_KEY=${LINKUP_API_KEY}
      - SMARTBUCKET_API_KEY=${SMARTBUCKET_API_KEY}
      - FREEPIK_API_KEY=${FREEPIK_API_KEY}
    command: >
      python -m app.worker   # your Temporal worker entrypoint
```

* `app.worker` module should:

  * Create Temporal client (`address=os.getenv("TEMPORAL_HOST")`)
  * Run your worker with:

    * `ResearchCompanyWorkflow`, `SelfLearningWorkflow`
    * All activities

Now you can run everything via:

```bash
docker compose up --build
```

Then:

* Temporal UI: `http://localhost:8233`
* Your app: `http://localhost:8000`

For the hackathon, you can demo:

1. Temporal Web UI showing workflows running.
2. Your own “pretty” UI at `localhost:8000` showing the agent output.

---

## 8. 3-Minute Demo Script Using This UI

You can literally follow this:

1. **Intro (20–30s)**

   * Show the home page.
   * “This is our Self-Evolving Account Researcher. It uses Linkup, Browser Use, SmartBuckets, Freepik, Anthropic, and Temporal to keep account research fresh and self-improving.”

2. **Live run (60s)**

   * Type in a known company (one you pre-tested).
   * Click “Run Research Agent.”
   * As steps update on the status card, flip briefly to Temporal Web UI to show the workflow execution.
   * When complete, show:

     * Brief tab (1-pager)
     * Outreach tab (ready-to-send LinkedIn message)
     * Evidence tab (pages + usefulness scores)
     * Visual Snapshot tab (Freepik card)

3. **Self-learning (60s)**

   * Navigate to “Policy Evolution.”
   * Point at:

     * Policy v1 vs v2 diff.
     * Improvements (e.g., better avg usefulness).
   * Explain: “At the end of each batch of runs, our SelfLearningWorkflow runs in Temporal, uses Claude to analyze past metrics and rewrite the browsing policy. That’s why we call it self-evolving.”

4. **Close (30s)**

   * “All of this runs locally in Docker: Temporal, our workers, and the UI. You could drop it into a sales team today as an always-on account researcher.”

---

If you’d like, I can next give you:

* A concrete `index.html` with Tailwind classes for the “Run Agent” page, or
* The skeleton `app.main` FastAPI routes wired to these templates and APIs so you can paste them into your repo and start filling in logic.
